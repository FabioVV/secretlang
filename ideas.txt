TODO: fix tests

TODO: store the line of code of the instruction in the instruction_position hash, much easier

1 - Add error correction suggestion:
context aware suggestions
spelling checking with Levenshtein Distance

 - Add more specialized instructions like addi (i know both are integers, dispacth a instructions that does not type checking during runtime and just adds them)

 - add simple type checking before runtime so that the specialized instructions from above can work

 - Change error text from the current expected both to be, got ? to this: expect expectec both to be ?, but got ? and ?

 - Just go around parsing showing the errors and do not append to a list of errors, instead set a field hadError, that if its value is true, do not compile the program
 - Add type inferring the in parser/compiler, that way i can optmize some operations like sum. So, instead of doing runtime type checks, if i know iam adding two numbers, have a separate instruction for addition that does no type checking

 - fix strings handling/interning !IMPORTANT

 - Have a options to output a dump/object file that later the VM can run by itself, without going through the entire pipeline(executables but for the VM, i think)


- Maybe have a simple line arguments like -sf (safe), when the user passes it in, it enables some runtime checks? like arity checking etc
i dont know

2.1 - other ideas

// some stupid ideas.....

module math
    @imports("math_helpers.ext") // imports as math_helpers.something
    const mthp = @imports("math_helpers.ext") // imports as mthp.something

end

maybe allow submodules?





const std = @import("std");
const builtin = @import("builtin");

pub fn _print_(value: []const u8) void {
    std.debug.print("{s}\n", .{value});
}

pub fn _printtwo_(value: i64, valuet: i64) void {
    std.debug.print("{d} and {d}\n", .{ value, valuet });
}

const nativeFn = struct {
    gindex: u16,
    name: []const u8,
    arity: u8,
    function: union {
        nprint: *const fn ([]const u8) void,
        nbprintt: *const fn (i64, i64) void,
    },

    pub fn initPrint(function: *const fn ([]const u8) void, name: []const u8, arity: u8, gindex: u16) nativeFn {
        return nativeFn{
            .function = .{ .nprint = function },
            .name = name,
            .arity = arity,
            .gindex = gindex,
        };
    }
};

var globals = std.BoundedArray(nativeFn, 5).init(5) catch unreachable;

pub fn main() void {
    const n = nativeFn.initPrint(_print_, "@print", 1, 0);
    globals.slice()[0] = n;

    globals.slice()[0].function.nprint("God is good!!! All the time.");
}



